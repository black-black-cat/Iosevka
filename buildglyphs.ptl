import 'unorm' as unorm

import './support/glyph' as Glyph
import './support/point' as Point
import './support/spirokit' as spirokit
import './support/transform' as : Transform && [object [transformPoint tp] [untransform utp] inverse]
import './support/anchor' as Anchor
import './support/monotonic-interpolate' as smoothreg
import './support/fairify' as fairify

import [mix linreg clamp fallback TempFont includeGlyphPart compsiteMarkSet suggestGC] from './support/utils'
import [calculateMetrics setFontMetrics] from './meta/aesthetics'
import [nameFont] from './meta/naming'

### Autoarg macro
define [$NamedParameterPair$ l r] : begin
	set this.left l
	set this.right r
	return this

define-operator "--" 890 'right' : syntax-rules
	`(@l -- @r) [atom l] `[new $NamedParameterPair$ @{".quote" [formOf l]} @r]
define-operator "~>" 880 'right' : syntax-rules
	`(@l ~> @r) `{.left @l .right @r}

define-macro params : syntax-rules
	`[params @_pairs @body] : begin
		local ta : env.newt
		local tb : env.newt
		local t : env.newt
		local ps `[begin
			[local @ta : {}.slice.call arguments 0]
			[local @tb {}]
			[for [local @t 0] (@t < @ta.length) [inc @t] : if [not : @ta.(@t) <@ $NamedParameterPair$] : @tb.push @ta.(@t)]
		]
		local aps `[begin]
		local dps `[begin]
		local j 0
		foreach [pf : items-of : formOf _pairs] : begin
			local name
			if [atom pf] : then
				ps.push `[local @pf : fallback @pf (@tb).(@{".quote" j})]
				set name pf
			: else
				ps.push `[local @(pf.0) : fallback @(pf.0) (@tb).(@{".quote" j}) @(pf.1)]
				set name pf.0
			aps.push `[if (@t && @t <@ $NamedParameterPair$ && @t.left == @{".quote" name}) [set @name @t.right]]
			if pf.2 : dps.push `[local @(pf.2) @name]
			inc j
		ps.push `[foreach [@t : items-of @ta] @aps]
		ps.push dps
		ps.push : formOf body
		return : dirty ps

### Point macro
define-operator "<>" 800 "never" : begin
	local tClass [definingEnv.newt 'class']
	local m : syntax-rules
		`(@x <> @y) `[new @tClass @x @y]

	set coinit.initFn : lambda [m] : begin
		set m.toPattern : lambda [form env wrapper] : match form
			`(@x <> @y) : begin
				local p1 [toPattern x env wrapper]
				local p2 [toPattern y env wrapper]
				object
					whether : lambda [t] `(@t && @[p1.whether `(@t.x)] && @[p2.whether `(@t.y)])
					assign : lambda [t locallyQ] : ex `[begin
						@{".preserve" [p1.assign `(@t.x) locallyQ]}
						@{".preserve" [p2.assign `(@t.y) locallyQ]}
					] env

	set coinit.injectForm `[define [@tClass x y] : begin \\
		set this.x x
		set this.y y
		return nothing
	]
	return m

# A symbol block defines a group of similar glyphs. They may expose some functions used in glyphs in other blocks.
define-macro symbol-block : syntax-rules
	`[symbol-block @name @::steps] : let [t : env.newt] : dirty `[begin [let : set @t : begin @::[steps.map formOf]] [progress @name] @t]

### Necessary macros
# A glyph construction is a function which "modifies" a glyph.
define-macro glyph-construction : syntax-rules
	`[glyph-construction @::steps] {'.syntactic-closure' `[lambda [] [begin \\
		local currentGlyph this
		begin @::[steps.map formOf]
		return nothing
	]] env}
# Remap Glyph's methods to macros in order to simplify writing
define-macro set-width : syntax-rules
	`[set-width @::args] {'.syntactic-closure' `[currentGlyph.set-width @::args] env}
define-macro start-from : syntax-rules
	`[start-from @::args] {'.syntactic-closure' `[currentGlyph.start-from @::args] env}
define-macro line-to : syntax-rules
	`[line-to @::args] {'.syntactic-closure' `[currentGlyph.line-to @::args] env}
define-macro curve-to : syntax-rules
	`[curve-to @::args] {'.syntactic-closure' `[currentGlyph.curve-to @::args] env}
define-macro cubic-to : syntax-rules
	`[cubic-to @::args] {'.syntactic-closure' `[currentGlyph.cubic-to @::args] env}
define-macro include : syntax-rules
	`[include glyphs.(@name) @::args] : dirty `[includeGlyphPart currentGlyph glyphs @name @::args]
	`[include @::args] {'.syntactic-closure' `[currentGlyph.include @::args] env}
define-macro set-anchor : syntax-rules
	`[set-anchor @::args] {'.syntactic-closure' `[currentGlyph.set-anchor @::args] env}
define-macro apply-transform : syntax-rules
	`[apply-transform @::args] {'.syntactic-closure' `[currentGlyph.apply-transform @::args] env}
define-macro reverse-last : syntax-rules
	`[reverse-last @::args] {'.syntactic-closure' `[currentGlyph.reverse-last @::args] env}
define-macro depends-on : syntax-rules
	`[depends-on @::args] {'.syntactic-closure' `[currentGlyph.depends-on @::args] env}
define-macro eject-contour : syntax-rules
	`[eject-contour @::args] {'.syntactic-closure' `[currentGlyph.eject-contour @::args] env}
define-macro tag-contour : syntax-rules
	`[tag-contour @::args] {'.syntactic-closure' `[currentGlyph.tag-contour @::args] env}
define-macro retag-contour : syntax-rules
	`[retag-contour @::args] {'.syntactic-closure' `[currentGlyph.retag-contour @::args] env}
define-macro assign-unicode : syntax-rules
	`[assign-unicode @code] {".syntactic-closure" `[begin \\
		currentGlyph.assign-unicode @code
		set unicodeGlyphs.(currentGlyph.unicode.((currentGlyph.unicode.length - 1))) currentGlyph
	] env}

###### Canvas-based mechanism
define [$donothing$] nothing
define-macro sketch : syntax-rules
	`[sketch @::steps] : begin
		if [not externEnv.$nWFGlyphs$] : set externEnv.$nWFGlyphs$ 0
		inc externEnv.$nWFGlyphs$
		dirty `[[lambda [currentGlyph] [begin \\
			if [not currentGlyph] : return nothing
			if [glyphList.(glyphList.length - 1).name === @{".quote" (".WF" + externEnv.$nWFGlyphs$)}] : glyphList.pop
			begin @::[steps.map formOf]
			set dependencyProfile.(currentGlyph.name) : getDependencyProfile currentGlyph
			return currentGlyph
		]] [create-glyph @{".quote" (".WF" + externEnv.$nWFGlyphs$)} $donothing$]]

define-macro branch : syntax-rules
	`[branch @::steps] : begin
		if [not externEnv.$nWFGlyphs$] : set externEnv.$nWFGlyphs$ 0
		inc externEnv.$nWFGlyphs$
		dirty `[[lambda [currentGlyph] [begin \\
			if [not currentGlyph] : return nothing
			if [glyphList.(glyphList.length - 1).name === @{".quote" (".WF" + externEnv.$nWFGlyphs$)}] : glyphList.pop
			begin @::[steps.map formOf]
			set dependencyProfile.(currentGlyph.name) : getDependencyProfile currentGlyph
			return currentGlyph
		]] [create-glyph @{".quote" (".WF" + externEnv.$nWFGlyphs$)} [lambda : begin [this.include currentGlyph true] [set this.advanceWidth currentGlyph.advanceWidth]]]]

define-macro save : syntax-rules
	`[save @::args] : dirty `[$save$.call currentGlyph @::args]

# contour tagging
define [tagged tag component] : begin
	set component.tag tag
	return component

# Main build procedure
export as build : define [buildFont para recursive recursiveCodes] : begin
	define variantSelector para.variantSelector
	define font this

	define glyphList font.glyf
	define glyphs {.}
	define unicodeGlyphs {}

	# Progress indicator
	define [progress status] : if [not recursive] : begin
		if para.verbose : console.log "    \(font.name.uniqueSubFamily) : Done \(status)"
		#suggestGC
		return nothing
	
	define metrics : calculateMetrics para
	define [object 
		UPM WIDTH SB CAP XH DESCENDER CONTRAST
		parenMid parenTop parenBot operTop operBot operMid Italify Upright Scale Translate Rotate globalTransform
		TANSLANT SINSLANT COSSLANT HVCONTRAST UPWARD DOWNWARD RIGHTWARD LEFTWARD
		O OX OXHOOK HOOK AHOOK SHOOK RHOOK JHOOK FHOOK HOOKX SMOOTH SMALLSMOOTH STROKE DOTSIZE PERIODSIZE
		BARPOS GBARPOS PBARPOS EBARPOS OVERLAYPOS FIVEBARPOS LONGJUT JUT VJUT ACCENT ACCENTX CTHIN CTHINB SLAB
		TAILADJX TAILADJY LBALANCE IBALANCE JBALANCE JBALANCE2 TBALANCE TBALANCE2 RBALANCE RBALANCE2
		FBALANCE ONEBALANCE FULLWIDTH FULLWIDTH1 FULLWIDTH2 FULLWIDTH3 OXE ESS ESSQUESTION XO CAPO HALFSTROKE RIGHTSB FWRSB
		MIDDLE FWMIDDLE CAPMIDDLE CAP_SMOOTH DOTRADIUS PERIODRADIUS SIDEJUT SMOOTHA SMOOTHB SMALLSMOOTHA SMALLSMOOTHB CORRECTION_OMIDX CORRECTION_OMIDS
		WHITENESS adviceBlackness MVERTSTROKE OVERLAYSTROKE OPERATORSTROKE SHOULDERFINE SUPERNESS superxy
		adviceSSmooth adviceGlottalStopSmooth shoulderMidSlope] metrics

	# Anchor parameters
	define [object MARK BASE] Anchor
	define {AS_BASE ALSO_METRICS} {'AS-BASE' 'ALSO-METRICS'}

	define markset : do
		define [ta anchor] : return : new Anchor
			* (anchor.x * globalTransform.xx + anchor.y * TANSLANT + globalTransform.x)
			* (anchor.x * globalTransform.xy + anchor.y * globalTransform.yy + globalTransform.y)
			* anchor.type

		define markAboveLower       {.anchors {.above       [ta : new Anchor MIDDLE  XH        BASE]}}
		define markAboveCap         {.anchors {.above       [ta : new Anchor MIDDLE  CAP       BASE]}}
		define markBelowLower       {.anchors {.below       [ta : new Anchor MIDDLE  DESCENDER BASE]}}
		define markBelowZero        {.anchors {.below       [ta : new Anchor MIDDLE  0         BASE]}}
		define markToprightLower    {.anchors {.topright    [ta : new Anchor RIGHTSB XH        BASE]}}
		define markToprightCap      {.anchors {.topright    [ta : new Anchor RIGHTSB CAP       BASE]}}
		define markBottomrightLower {.anchors {.bottomright [ta : new Anchor RIGHTSB DESCENDER BASE]}}
		define markBottomrightZero  {.anchors {.bottomright [ta : new Anchor RIGHTSB 0         BASE]}}

		define [buildStandardMarkSet] : begin
			local a : compsiteMarkSet.apply null arguments
			set a.anchors.overlay : new Anchor
				* [mix a.anchors.below.x a.anchors.above.x OVERLAYPOS]
				* [mix a.anchors.below.y a.anchors.above.y OVERLAYPOS]
				* BASE
			set a.anchors.slash : new Anchor
				* [mix a.anchors.below.x a.anchors.above.x 0.5]
				* [mix a.anchors.below.y a.anchors.above.y 0.5]
				* BASE
			return a
		
		object
			capital : buildStandardMarkSet markAboveCap markBelowZero markToprightCap markBottomrightZero
			b       : buildStandardMarkSet markAboveCap markBelowZero markToprightCap markBottomrightZero
			e       : buildStandardMarkSet markAboveLower markBelowZero markToprightLower markBottomrightZero
			p       : buildStandardMarkSet markAboveLower markBelowLower markToprightLower markBottomrightLower
			if      : buildStandardMarkSet markAboveCap markBelowLower markToprightCap markBottomrightLower


	### Glyph slots and dependency profile generation (used for recursive subfonts)
	local dependencyProfile {.}
	local nTemp 0
	local nPending 0
	local pickHash : if recursive
		then : let [h {.}] : begin
			foreach j [items-of recursive] : set h.(j) j
			set nPending recursive.length
			* h
		else nothing
	define [getDependencyProfile glyph] : begin
		local dp {}
		foreach d [items-of glyph.dependencies] : begin
			dp.push d
			if dependencyProfile.(d): foreach [k : items-of dependencyProfile.(d)] : dp.push k
		return dp
	define [create-glyph] : match [Array.prototype.slice.call arguments 0]
		`[@name @actions] : begin
			if (pickHash && nPending <= 0) : begin
				if para.verbose : console.log "    *** Done recursive build for \[if (recursive.length > 3) [recursive.slice 0 3 :.concat {'...'} :.join ','] [recursive.join ',']] in \(font.name.uniqueSubFamily)"
				throw {.glyfMap glyphs}
			if (pickHash && [not pickHash.(name)]) : return nothing

			if para.verbose : console.log name
			local glyphObject [new Glyph name]
			glyphList.push glyphObject
			glyphs.(name) = glyphObject
			glyphObject.set-width WIDTH
			glyphObject.gizmo = globalTransform

			actions.call glyphObject

			set dependencyProfile.(name) : getDependencyProfile glyphObject
			dec nPending
			return glyphObject

		`[@actions] : begin
			local glyphName ('.temp-' + [set nTemp (nTemp + 1)])
			if para.verbose : console.log glyphName
			local glyphObject [new Glyph glyphName]
			glyphObject.set-width WIDTH
			glyphObject.gizmo = globalTransform
			actions.call glyphObject
			return glyphObject

	define [$save$ name unicode] : begin
		local t this
		local g : create-glyph name [lambda]
		if g : begin
			g.include t AS_BASE
			set g.advanceWidth t.advanceWidth
			set g.shortName t.shortName
			set g.cmpPriority t.cmpPriority
			if name : set dependencyProfile.(name) : getDependencyProfile g
		if (g && unicode) : begin
			g.assign-unicode unicode
			set unicodeGlyphs.(g.unicode.((g.unicode.length - 1))) g
		return g

	### Spiro constructions
	# Basic knots
	local [object
		g4 g2 corner flat curl close end straight
		widths heading unimportant important
		alsothru alsothruthem bezcontrols quadcontrols archv arcvh complexThru
		dispiro spiro-outline] : spirokit.SetupBuilders : object globalTransform CONTRAST STROKE Glyph para SUPERNESS

	###### HERE WE GO!

	### Metadata
	nameFont para metrics font
	setFontMetrics para metrics font

	# Metric metadata
	# Note: we use 1000upm in design, and (1000 * upmsacle)upm in production, to avoid rounding error.

	let [asc : para.leading * CAP / (CAP - DESCENDER)] [desc : para.leading * DESCENDER / (CAP - DESCENDER)] : begin
		local descenderPad : fallback para.descenderPad 0
		set font.head.unitsPerEm        1000
		set font.hhea.ascender          asc
		set font.OS_2.usWinAscent       asc
		set font.OS_2.sTypoAscender     asc

		set font.hhea.descender         (DESCENDER - descenderPad)
		set font.OS_2.usWinDescent      ([Math.abs desc] + descenderPad)
		set font.OS_2.sTypoDescender    (desc - descenderPad)

		set font.hhea.lineGap           (para.leading - asc + DESCENDER)
		set font.OS_2.sTypoLineGap      (para.leading - asc + desc)

		set font.OS_2.sxHeight          XH
		set font.OS_2.sCapHeight        CAP
		set font.post.italicAngle       (0 - para.slantAngle)

	# Necessary notdef, .null and nonmarkingreturn glyph
	sketch # .notdef
		start-from SB 0
		line-to    SB CAP
		line-to    RIGHTSB CAP
		line-to    RIGHTSB 0

		start-from (SB + STROKE) STROKE
		line-to    (RIGHTSB - STROKE) STROKE
		line-to    (RIGHTSB - STROKE) (CAP - STROKE)
		line-to    (SB + STROKE) (CAP - STROKE)
		set currentGlyph.cmpPriority (9999)
		save '.notdef'
	sketch # .null
		set-width 0
		set currentGlyph.cmpPriority (9998)
		save '.null'
	sketch # nonmarkingreturn
		set-width WIDTH
		set currentGlyph.cmpPriority (-1)
		save 'nonmarkingreturn' 0x000D

	# Space
	sketch # space
		set-width WIDTH
		include markset.e
		save 'space' ' '

	### HERE WE GO
	$$include 'glyphs/common-shapes.ptl'
	$$include 'glyphs/overmarks.ptl'

	# Unified letters
	$$include 'glyphs/letters-unified-basic.ptl'
	$$include 'glyphs/letters-unified-extended.ptl'

	# Numbers
	$$include 'glyphs/numbers.ptl'

	# Symbols
	$$include 'glyphs/symbol-punctuation.ptl'
	$$include 'glyphs/symbol-math.ptl'
	$$include 'glyphs/symbol-letter.ptl'
	$$include 'glyphs/symbol-geometric.ptl'
	$$include 'glyphs/symbol-braille.ptl'
	$$include 'glyphs/symbol-other.ptl'

	# Autobuilds
	set font.features {.}
	$$include 'glyphs/autobuilds.ptl'
	$$include 'glyphs/features.ptl'

	set font.glyfMap glyphs
	return font
